<html>
	<head>
		<title>glitchyCubes</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
		<script src="CopyShader.js"></script>
		<script src="DigitalGlitch.js"></script>
		<script src="EffectComposer.js"></script>
		<script src="RGBShiftShader.js"></script>
		<script src="DotScreenShader.js"></script>
		<script src="FilmShader.js"></script>
		<script src="BokehShader.js"></script>

		<script src="RendererPass.js"></script>
		<script src="MaskPass.js"></script>
		<script src="ShaderPass.js"></script>
		<script src="GlitchPass.js"></script>
		<script src="FilmPass.js"></script>
		<script src="BokehPass.js"></script>
		<script>

			var scene, camera, renderer, composer, material, geometry, light;

			var glitchPass = {}, rgbEffect, filmEffect, bokehPass;

			var mouseX = 0, mouseY = 0;

			var colors = [0x9BFF66, 0xffff66];

			var cubes = [];

			function makeCube (c) {
				var cube = new THREE.Mesh( geometry, material );

				cube.position.x = c.x;
				cube.position.y = c.y;
				cube.position.z = c.z;

				return {
					obj: cube,
					speed: c.speed,
					rotation: c.rotation
				}
			}

			function init (){
				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000);

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				geometry = new THREE.BoxGeometry( 10, 10, 10);

				material = new THREE.MeshPhongMaterial({color: colors[Math.floor(Math.random()*colors.length)], shininess: 5});

				light = new THREE.DirectionalLight( 0xffffff, 0.5 );
				light.position.set( 0, 0, 20 );
				scene.add( light );

				//postprocessing
				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );
				glitchPass = new THREE.GlitchPass(10,10);
				//glitchPass.renderToScreen = true;
				glitchPass.goWild=false;
				composer.addPass( glitchPass );

				filmEffect = new THREE.FilmPass(0.9,0.27,7000,0.3);
				filmEffect.renderToScreen = true;
				composer.addPass(filmEffect);

				camera.position.z = 500;

				var i = 0;
				for (;i<10000;i++){
					cubes.push(makeCube({
						x: Math.random()*400-200,
						y: Math.random()*400-200,
						z: -Math.random()*6000,
						speed: {
							x: 0,
							y: 0,
							z: Math.random()+8
						},
						rotation: {
							x: (Math.random()-0.5)/7,
							y: (Math.random()-0.5)/7
						}
					}));

					scene.add(cubes[i].obj);
				}
			}

			init ();


			function collisionDetection (cube, camera, edgeLen){
				var d = (cube.position.x-camera.position.x)*(cube.position.x-camera.position.x)+(cube.position.y-camera.position.y)*(cube.position.y-camera.position.y)+(cube.position.z-camera.position.z)*(cube.position.z-camera.position.z);
				if (d<60) return true;
				return false;
			}

			function updateCubes (cubes){
				var i = 0;
				for (;i<cubes.length;i++) {
					cubes[i].obj.position.x += cubes[i].speed.x;
					cubes[i].obj.position.y += cubes[i].speed.y;
					cubes[i].obj.position.z += cubes[i].speed.z;

					cubes[i].obj.rotation.x += cubes[i].rotation.x;
					cubes[i].obj.rotation.y += cubes[i].rotation.y;

					if (glitchPass.goWild===false && collisionDetection(cubes[i].obj,camera,10) === true) {
						glitchPass.goWild=true;

						setTimeout(function(){
							glitchPass.goWild=false;
						}, Math.random()*500 + 500);
					}

					var removeAfter = 100;
					if (cubes[i].obj.position.z >= camera.position.z + removeAfter) {
						cubes[i].obj.position.x =	Math.random()*400-200;
						cubes[i].obj.position.y =	Math.random()*400-200;
						cubes[i].obj.position.z = -6000 + camera.position.z + removeAfter;

						cubes[i].obj.rotation.x = (Math.random()-0.5)/7;
						cubes[i].obj.rotation.y = (Math.random()-0.5)/7;

						cubes[i].speed.z = Math.random()+8;
					}
				}
			}

			var render = function () {
				requestAnimationFrame(render);

				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( - mouseY - camera.position.y ) * .05 ;

				//light.position.x = camera.position.x;
				//light.position.y = camera.position.y;

				updateCubes (cubes);

				composer.render();
				//renderer.render(scene, camera);
			};

			document.onmousemove = function(e){
				var k = 683;
				var windowHalfX = window.innerWidth / 2;
			 	var windowHalfY = window.innerHeight / 2;
			 	mouseX = ( e.pageX - windowHalfX ) / 2 * (k/window.innerWidth);
			 	mouseY = ( e.pageY - windowHalfY ) / 2 * (k/window.innerHeight);
			}

			window.onresize = function() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			render();
		</script>
	</body>
</html>
